{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Index \u00b6 KKafka is a Kotlin library around the Kafka Clients java library, with a focus on providing an idiomatic Kotlin asynchronous API thanks to coroutines , rather than using callbacks Java-style. Quick start \u00b6 Gradle \u00b6 depndencies { implementation ( \"TODO\" ) } A consumer \u00b6 val props = Properties (). apply { setProperty ( \"bootstrap.servers\" , \"localhost:9092\" ) setProperty ( \"group.id\" , \"test\" ) setProperty ( \"enable.auto.commit\" , \"true\" ) setProperty ( \"key.deserializer\" , \"org.apache.kafka.common.serialization.StringDeserializer\" ) setProperty ( \"value.deserializer\" , \"org.apache.kafka.common.serialization.StringDeserializer\" ) } val consumer = KafkaConsumer < String , String > ( props ) consumer . subscribe ( listOf ( \"foo\" , \"bar\" )) consumer . pollWithFlow . collect { batch -> insertIntoDb ( batch . toList ()) }","title":"Index"},{"location":"#index","text":"KKafka is a Kotlin library around the Kafka Clients java library, with a focus on providing an idiomatic Kotlin asynchronous API thanks to coroutines , rather than using callbacks Java-style.","title":"Index"},{"location":"#quick-start","text":"","title":"Quick start"},{"location":"#gradle","text":"depndencies { implementation ( \"TODO\" ) }","title":"Gradle"},{"location":"#a-consumer","text":"val props = Properties (). apply { setProperty ( \"bootstrap.servers\" , \"localhost:9092\" ) setProperty ( \"group.id\" , \"test\" ) setProperty ( \"enable.auto.commit\" , \"true\" ) setProperty ( \"key.deserializer\" , \"org.apache.kafka.common.serialization.StringDeserializer\" ) setProperty ( \"value.deserializer\" , \"org.apache.kafka.common.serialization.StringDeserializer\" ) } val consumer = KafkaConsumer < String , String > ( props ) consumer . subscribe ( listOf ( \"foo\" , \"bar\" )) consumer . pollWithFlow . collect { batch -> insertIntoDb ( batch . toList ()) }","title":"A consumer"},{"location":"examples/consumer/","text":"Consumer \u00b6 Rather than writing a polling loop, KKafka allows you to simply receive records as an asynchronous Flow . Because Flows are cold and sequential, they are great to process records without having to worry about the mechanics of when to poll for records: val props = Properties (). apply { setProperty ( \"enable.auto.commit\" , \"true\" ) // and your other settings } val consumer = KafkaConsumer < String , String > ( props ) var active = true consumer . subscribe ( listOf ( \"foo\" , \"bar\" )) val flow = consumer . pollWithFlattenedFlow () . takeWhile { active } . onEach { println ( \"Received text $ it \" ) } . filter { ( _ , v ) -> v . isBlank () } . onEach { ( k , v ) -> insertIntoDb ( k , v ) } . collect () Note how: We use higher order functions like filter() , rather than stateful loops We are able to call other suspending functions while processing our records The flow is cold: we will only poll for the next record once we are done with the current one We can cleanly stop the polling at any time by setting active = false .","title":"Consumer"},{"location":"examples/consumer/#consumer","text":"Rather than writing a polling loop, KKafka allows you to simply receive records as an asynchronous Flow . Because Flows are cold and sequential, they are great to process records without having to worry about the mechanics of when to poll for records: val props = Properties (). apply { setProperty ( \"enable.auto.commit\" , \"true\" ) // and your other settings } val consumer = KafkaConsumer < String , String > ( props ) var active = true consumer . subscribe ( listOf ( \"foo\" , \"bar\" )) val flow = consumer . pollWithFlattenedFlow () . takeWhile { active } . onEach { println ( \"Received text $ it \" ) } . filter { ( _ , v ) -> v . isBlank () } . onEach { ( k , v ) -> insertIntoDb ( k , v ) } . collect () Note how: We use higher order functions like filter() , rather than stateful loops We are able to call other suspending functions while processing our records The flow is cold: we will only poll for the next record once we are done with the current one We can cleanly stop the polling at any time by setting active = false .","title":"Consumer"}]}